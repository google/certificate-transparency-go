// Code generated by protoc-gen-go. DO NOT EDIT.
// source: config.proto

package configpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import any "github.com/golang/protobuf/ptypes/any"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"
import keyspb "github.com/google/trillian/crypto/keyspb"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LogBackend struct {
	// name defines the name of the log backend for use in LogConfig messages and must be unique.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// backend_spec defines the RPC endpoint that clients should use to send requests
	// to this log backend. These should be in the same format as rpcBackendFlag in the
	// CTFE main and must not be an empty string.
	BackendSpec          string   `protobuf:"bytes,2,opt,name=backend_spec,json=backendSpec,proto3" json:"backend_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogBackend) Reset()         { *m = LogBackend{} }
func (m *LogBackend) String() string { return proto.CompactTextString(m) }
func (*LogBackend) ProtoMessage()    {}
func (*LogBackend) Descriptor() ([]byte, []int) {
	return fileDescriptor_config_2bd128c78e56e658, []int{0}
}
func (m *LogBackend) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogBackend.Unmarshal(m, b)
}
func (m *LogBackend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogBackend.Marshal(b, m, deterministic)
}
func (dst *LogBackend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogBackend.Merge(dst, src)
}
func (m *LogBackend) XXX_Size() int {
	return xxx_messageInfo_LogBackend.Size(m)
}
func (m *LogBackend) XXX_DiscardUnknown() {
	xxx_messageInfo_LogBackend.DiscardUnknown(m)
}

var xxx_messageInfo_LogBackend proto.InternalMessageInfo

func (m *LogBackend) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LogBackend) GetBackendSpec() string {
	if m != nil {
		return m.BackendSpec
	}
	return ""
}

// LogBackendSet supports a configuration where a single set of frontends handle
// requests for multiple backends. For example this could be used to run different
// backends in different geographic regions.
type LogBackendSet struct {
	Backend              []*LogBackend `protobuf:"bytes,1,rep,name=backend,proto3" json:"backend,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LogBackendSet) Reset()         { *m = LogBackendSet{} }
func (m *LogBackendSet) String() string { return proto.CompactTextString(m) }
func (*LogBackendSet) ProtoMessage()    {}
func (*LogBackendSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_config_2bd128c78e56e658, []int{1}
}
func (m *LogBackendSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogBackendSet.Unmarshal(m, b)
}
func (m *LogBackendSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogBackendSet.Marshal(b, m, deterministic)
}
func (dst *LogBackendSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogBackendSet.Merge(dst, src)
}
func (m *LogBackendSet) XXX_Size() int {
	return xxx_messageInfo_LogBackendSet.Size(m)
}
func (m *LogBackendSet) XXX_DiscardUnknown() {
	xxx_messageInfo_LogBackendSet.DiscardUnknown(m)
}

var xxx_messageInfo_LogBackendSet proto.InternalMessageInfo

func (m *LogBackendSet) GetBackend() []*LogBackend {
	if m != nil {
		return m.Backend
	}
	return nil
}

// LogConfigSet is a set of LogConfig messages.
type LogConfigSet struct {
	Config               []*LogConfig `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LogConfigSet) Reset()         { *m = LogConfigSet{} }
func (m *LogConfigSet) String() string { return proto.CompactTextString(m) }
func (*LogConfigSet) ProtoMessage()    {}
func (*LogConfigSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_config_2bd128c78e56e658, []int{2}
}
func (m *LogConfigSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogConfigSet.Unmarshal(m, b)
}
func (m *LogConfigSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogConfigSet.Marshal(b, m, deterministic)
}
func (dst *LogConfigSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogConfigSet.Merge(dst, src)
}
func (m *LogConfigSet) XXX_Size() int {
	return xxx_messageInfo_LogConfigSet.Size(m)
}
func (m *LogConfigSet) XXX_DiscardUnknown() {
	xxx_messageInfo_LogConfigSet.DiscardUnknown(m)
}

var xxx_messageInfo_LogConfigSet proto.InternalMessageInfo

func (m *LogConfigSet) GetConfig() []*LogConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

// LogConfig describes the configuration options for a log instance.
type LogConfig struct {
	// The ID of a Trillian tree that stores the log data. The tree type must be
	// LOG for regular CT logs. For mirror logs it must be either PREORDERED_LOG
	// or LOG, and can change at runtime. CTFE in mirror mode uses only read API
	// which is common for both types.
	LogId int64 `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	// prefix is the name of the log. It will come after the global or
	// custom handler prefix. For example if the handler prefix is "/logs"
	// and prefix is "vogon" the get-sth handler for this log will be
	// available at "/logs/vogon/ct/v1/get-sth". The prefix cannot be empty
	// and must not include "/" path separator characters.
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Paths to the files containing root certificates that are acceptable to the
	// log. The certs are served through get-roots endpoint. Optional in mirrors.
	RootsPemFile []string `protobuf:"bytes,3,rep,name=roots_pem_file,json=rootsPemFile,proto3" json:"roots_pem_file,omitempty"`
	// The private key used for signing STHs etc. Not required for mirrors.
	PrivateKey *any.Any `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// The public key matching the above private key (if both are present). It is
	// used only by mirror logs for verifying the source log's signatures, but can
	// be specified for regular logs as well for the convenience of test tools.
	PublicKey *keyspb.PublicKey `protobuf:"bytes,5,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// If reject_expired is true then the certificate validity period will be
	// checked against the current time during the validation of submissions.
	// This will cause expired certificates to be rejected.
	RejectExpired bool `protobuf:"varint,6,opt,name=reject_expired,json=rejectExpired,proto3" json:"reject_expired,omitempty"`
	// If set, ext_key_usages will restrict the set of such usages that the
	// server will accept. By default all are accepted. The values specified
	// must be ones known to the x509 package.
	ExtKeyUsages []string `protobuf:"bytes,7,rep,name=ext_key_usages,json=extKeyUsages,proto3" json:"ext_key_usages,omitempty"`
	// not_after_start defines the start of the range of acceptable NotAfter
	// values, inclusive.
	// Leaving this unset implies no lower bound to the range.
	NotAfterStart *timestamp.Timestamp `protobuf:"bytes,8,opt,name=not_after_start,json=notAfterStart,proto3" json:"not_after_start,omitempty"`
	// not_after_limit defines the end of the range of acceptable NotAfter values,
	// exclusive.
	// Leaving this unset implies no upper bound to the range.
	NotAfterLimit *timestamp.Timestamp `protobuf:"bytes,9,opt,name=not_after_limit,json=notAfterLimit,proto3" json:"not_after_limit,omitempty"`
	// accept_only_ca controls whether or not *only* certificates with the CA bit
	// set will be accepted.
	AcceptOnlyCa bool `protobuf:"varint,10,opt,name=accept_only_ca,json=acceptOnlyCa,proto3" json:"accept_only_ca,omitempty"`
	// backend_name if set indicates which backend serves this log. The name must be
	// one of those defined in the LogBackendSet.
	LogBackendName string `protobuf:"bytes,11,opt,name=log_backend_name,json=logBackendName,proto3" json:"log_backend_name,omitempty"`
	// If set, the log is a mirror, i.e. it serves the data of another (source)
	// log. It doesn't handle write requests (add-chain, etc.), so it's not a
	// fully fledged RFC-6962 log, but the tree read requests like get-entries and
	// get-consistency-proof are compatible. A mirror doesn't have the source
	// log's key and can't sign STHs. Consequently, the log operator must ensure
	// to channel source log's STHs into CTFE.
	IsMirror bool `protobuf:"varint,12,opt,name=is_mirror,json=isMirror,proto3" json:"is_mirror,omitempty"`
	// custom_handler_prefix if set to a non empty value overrides the global
	// handler prefix for an individual log. For example this field is set to
	// "/otherlogs" then a log with prefix "vogon" will make it's get-sth handler
	// available at "/otherlogs/vogon/ct/v1/get-sth" regardless of what the
	// global prefix is. Can be set to '/' to make the get-sth handler register
	// at "/vogon/ct/v1/get-sth".
	CustomHandlerPrefix  string   `protobuf:"bytes,13,opt,name=custom_handler_prefix,json=customHandlerPrefix,proto3" json:"custom_handler_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogConfig) Reset()         { *m = LogConfig{} }
func (m *LogConfig) String() string { return proto.CompactTextString(m) }
func (*LogConfig) ProtoMessage()    {}
func (*LogConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_config_2bd128c78e56e658, []int{3}
}
func (m *LogConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogConfig.Unmarshal(m, b)
}
func (m *LogConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogConfig.Marshal(b, m, deterministic)
}
func (dst *LogConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogConfig.Merge(dst, src)
}
func (m *LogConfig) XXX_Size() int {
	return xxx_messageInfo_LogConfig.Size(m)
}
func (m *LogConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LogConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LogConfig proto.InternalMessageInfo

func (m *LogConfig) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *LogConfig) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *LogConfig) GetRootsPemFile() []string {
	if m != nil {
		return m.RootsPemFile
	}
	return nil
}

func (m *LogConfig) GetPrivateKey() *any.Any {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *LogConfig) GetPublicKey() *keyspb.PublicKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *LogConfig) GetRejectExpired() bool {
	if m != nil {
		return m.RejectExpired
	}
	return false
}

func (m *LogConfig) GetExtKeyUsages() []string {
	if m != nil {
		return m.ExtKeyUsages
	}
	return nil
}

func (m *LogConfig) GetNotAfterStart() *timestamp.Timestamp {
	if m != nil {
		return m.NotAfterStart
	}
	return nil
}

func (m *LogConfig) GetNotAfterLimit() *timestamp.Timestamp {
	if m != nil {
		return m.NotAfterLimit
	}
	return nil
}

func (m *LogConfig) GetAcceptOnlyCa() bool {
	if m != nil {
		return m.AcceptOnlyCa
	}
	return false
}

func (m *LogConfig) GetLogBackendName() string {
	if m != nil {
		return m.LogBackendName
	}
	return ""
}

func (m *LogConfig) GetIsMirror() bool {
	if m != nil {
		return m.IsMirror
	}
	return false
}

func (m *LogConfig) GetCustomHandlerPrefix() string {
	if m != nil {
		return m.CustomHandlerPrefix
	}
	return ""
}

// LogMultiConfig wraps up a LogBackendSet and corresponding LogConfigSet so
// that they can easily be parsed as a single proto.
type LogMultiConfig struct {
	// The set of backends that this configuration will use to send requests to.
	// The names of the backends in the LogBackendSet must all be distinct.
	Backends *LogBackendSet `protobuf:"bytes,1,opt,name=backends,proto3" json:"backends,omitempty"`
	// The set of logs that will use the above backends. All the protos in this
	// LogConfigSet must set a valid log_backend_name for the config to be usable.
	LogConfigs           *LogConfigSet `protobuf:"bytes,2,opt,name=log_configs,json=logConfigs,proto3" json:"log_configs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LogMultiConfig) Reset()         { *m = LogMultiConfig{} }
func (m *LogMultiConfig) String() string { return proto.CompactTextString(m) }
func (*LogMultiConfig) ProtoMessage()    {}
func (*LogMultiConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_config_2bd128c78e56e658, []int{4}
}
func (m *LogMultiConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogMultiConfig.Unmarshal(m, b)
}
func (m *LogMultiConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogMultiConfig.Marshal(b, m, deterministic)
}
func (dst *LogMultiConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogMultiConfig.Merge(dst, src)
}
func (m *LogMultiConfig) XXX_Size() int {
	return xxx_messageInfo_LogMultiConfig.Size(m)
}
func (m *LogMultiConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LogMultiConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LogMultiConfig proto.InternalMessageInfo

func (m *LogMultiConfig) GetBackends() *LogBackendSet {
	if m != nil {
		return m.Backends
	}
	return nil
}

func (m *LogMultiConfig) GetLogConfigs() *LogConfigSet {
	if m != nil {
		return m.LogConfigs
	}
	return nil
}

func init() {
	proto.RegisterType((*LogBackend)(nil), "configpb.LogBackend")
	proto.RegisterType((*LogBackendSet)(nil), "configpb.LogBackendSet")
	proto.RegisterType((*LogConfigSet)(nil), "configpb.LogConfigSet")
	proto.RegisterType((*LogConfig)(nil), "configpb.LogConfig")
	proto.RegisterType((*LogMultiConfig)(nil), "configpb.LogMultiConfig")
}

func init() { proto.RegisterFile("config.proto", fileDescriptor_config_2bd128c78e56e658) }

var fileDescriptor_config_2bd128c78e56e658 = []byte{
	// 584 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0x41, 0x6f, 0xd3, 0x4c,
	0x10, 0x55, 0xbe, 0xb4, 0x69, 0x32, 0x4e, 0xf2, 0xc1, 0x96, 0x16, 0x53, 0x0e, 0x84, 0x08, 0xa4,
	0x48, 0x48, 0x0e, 0x4a, 0x55, 0x71, 0xe0, 0x80, 0xda, 0x0a, 0x04, 0x6a, 0x0a, 0x95, 0x03, 0xe7,
	0x95, 0xed, 0x4c, 0xdc, 0xa5, 0x6b, 0xef, 0x6a, 0x77, 0x83, 0xe2, 0x0b, 0x7f, 0x8d, 0xbf, 0x86,
	0xbc, 0xbb, 0x4e, 0x55, 0xe8, 0x81, 0x93, 0x3d, 0xf3, 0xde, 0x1b, 0xbd, 0xd9, 0x79, 0xd0, 0xcf,
	0x44, 0xb9, 0x62, 0x79, 0x24, 0x95, 0x30, 0x82, 0x74, 0x5d, 0x25, 0xd3, 0xa3, 0x93, 0x9c, 0x99,
	0xeb, 0x75, 0x1a, 0x65, 0xa2, 0x98, 0xe6, 0x42, 0xe4, 0x1c, 0xa7, 0x46, 0x31, 0xce, 0x59, 0x52,
	0x4e, 0x33, 0x55, 0x49, 0x23, 0xa6, 0x37, 0x58, 0x69, 0x99, 0xfa, 0x8f, 0x1b, 0x70, 0xf4, 0xc4,
	0x73, 0x6d, 0x95, 0xae, 0x57, 0xd3, 0xa4, 0xac, 0x3c, 0xf4, 0xec, 0x4f, 0xc8, 0xb0, 0x02, 0xb5,
	0x49, 0x0a, 0xe9, 0x08, 0xe3, 0x73, 0x80, 0xb9, 0xc8, 0xcf, 0x92, 0xec, 0x06, 0xcb, 0x25, 0x21,
	0xb0, 0x53, 0x26, 0x05, 0x86, 0xad, 0x51, 0x6b, 0xd2, 0x8b, 0xed, 0x3f, 0x79, 0x0e, 0xfd, 0xd4,
	0xc1, 0x54, 0x4b, 0xcc, 0xc2, 0xff, 0x2c, 0x16, 0xf8, 0xde, 0x42, 0x62, 0x36, 0x7e, 0x07, 0x83,
	0xdb, 0x21, 0x0b, 0x34, 0x24, 0x82, 0x3d, 0x8f, 0x87, 0xad, 0x51, 0x7b, 0x12, 0xcc, 0x1e, 0x45,
	0xcd, 0x92, 0xd1, 0x2d, 0x33, 0x6e, 0x48, 0xe3, 0xb7, 0xd0, 0x9f, 0x8b, 0xfc, 0xdc, 0x52, 0x6a,
	0xfd, 0x2b, 0xe8, 0x38, 0xbe, 0x97, 0xef, 0xdf, 0x91, 0x3b, 0x5e, 0xec, 0x29, 0xe3, 0x5f, 0x3b,
	0xd0, 0xdb, 0x76, 0xc9, 0x01, 0x74, 0xb8, 0xc8, 0x29, 0x5b, 0xda, 0x25, 0xda, 0xf1, 0x2e, 0x17,
	0xf9, 0xa7, 0x25, 0x39, 0x84, 0x8e, 0x54, 0xb8, 0x62, 0x1b, 0xef, 0xdf, 0x57, 0xe4, 0x05, 0x0c,
	0x95, 0x10, 0x46, 0x53, 0x89, 0x05, 0x5d, 0x31, 0x8e, 0x61, 0x7b, 0xd4, 0x9e, 0xf4, 0xe2, 0xbe,
	0xed, 0x5e, 0x61, 0xf1, 0x81, 0x71, 0x24, 0x27, 0x10, 0x48, 0xc5, 0x7e, 0x24, 0x06, 0xe9, 0x0d,
	0x56, 0xe1, 0xce, 0xa8, 0x65, 0x77, 0x72, 0x8f, 0x1b, 0x35, 0x8f, 0x1b, 0x9d, 0x96, 0x55, 0x0c,
	0x9e, 0x78, 0x81, 0x15, 0x79, 0x0d, 0x20, 0xd7, 0x29, 0x67, 0x99, 0x55, 0xed, 0x5a, 0xd5, 0xc3,
	0xc8, 0xdf, 0xee, 0xca, 0x22, 0x17, 0x58, 0xc5, 0x3d, 0xd9, 0xfc, 0x92, 0x97, 0x30, 0x54, 0xf8,
	0x1d, 0x33, 0x43, 0x71, 0x23, 0x99, 0xc2, 0x65, 0xd8, 0x19, 0xb5, 0x26, 0xdd, 0x78, 0xe0, 0xba,
	0xef, 0x5d, 0xb3, 0x76, 0x8d, 0x1b, 0x53, 0x4f, 0xa5, 0x6b, 0x9d, 0xe4, 0xa8, 0xc3, 0x3d, 0xe7,
	0x1a, 0x37, 0xe6, 0x02, 0xab, 0x6f, 0xb6, 0x47, 0xce, 0xe0, 0xff, 0x52, 0x18, 0x9a, 0xac, 0x0c,
	0x2a, 0xaa, 0x4d, 0xa2, 0x4c, 0xd8, 0xb5, 0x1e, 0x8e, 0xfe, 0x72, 0xfe, 0xb5, 0x89, 0x45, 0x3c,
	0x28, 0x85, 0x39, 0xad, 0x15, 0x8b, 0x5a, 0x70, 0x77, 0x06, 0x67, 0x05, 0x33, 0x61, 0xef, 0xdf,
	0x67, 0xcc, 0x6b, 0x41, 0xed, 0x36, 0xc9, 0x32, 0x94, 0x86, 0x8a, 0x92, 0x57, 0x34, 0x4b, 0x42,
	0xb0, 0x4b, 0xf5, 0x5d, 0xf7, 0x4b, 0xc9, 0xab, 0xf3, 0x84, 0x4c, 0xe0, 0x41, 0x7d, 0xb8, 0x26,
	0x6b, 0x36, 0x87, 0x81, 0xbd, 0xd5, 0x90, 0x6f, 0x23, 0xf3, 0xb9, 0x4e, 0xe4, 0x53, 0xe8, 0x31,
	0x4d, 0x0b, 0xa6, 0x94, 0x50, 0x61, 0xdf, 0x8e, 0xea, 0x32, 0x7d, 0x69, 0x6b, 0x32, 0x83, 0x83,
	0x6c, 0xad, 0x8d, 0x28, 0xe8, 0x75, 0x52, 0x2e, 0x39, 0x2a, 0xea, 0xef, 0x3e, 0xb0, 0xb3, 0xf6,
	0x1d, 0xf8, 0xd1, 0x61, 0x57, 0x16, 0x1a, 0xff, 0x84, 0xe1, 0x5c, 0xe4, 0x97, 0x6b, 0x6e, 0x98,
	0x4f, 0xd1, 0x31, 0x74, 0xbd, 0x11, 0x6d, 0x73, 0x14, 0xcc, 0x1e, 0xdf, 0x97, 0xe0, 0x05, 0x9a,
	0x78, 0x4b, 0x24, 0x6f, 0x20, 0xa8, 0x37, 0x70, 0x3c, 0x6d, 0x83, 0x16, 0xcc, 0x0e, 0xef, 0x89,
	0x6e, 0x2d, 0x03, 0xde, 0x54, 0x3a, 0xed, 0xd8, 0x37, 0x3c, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff,
	0x9a, 0x91, 0x84, 0xbe, 0x18, 0x04, 0x00, 0x00,
}
